import { ReportDestination, ReportProcessor, Artifact } from '../index'

/**
 * The Router class maps processors to destinations to streamline the process of
 * sending reports to various locations/services.
 *
 * A router implements {@link ReportDestination} since it's intended to be used as a {@link ReportDestination}.
 *
 * @param T - Type of report that is generated by processors and sent to destinations.
 * @see {@link ReportProcessor}
 * @see {@link ReportDestination}
 */
export class Router<T> implements ReportDestination<readonly Artifact[]> {
  /**
   * Internal map that routes processors to destinations.
   */
  private routes: Map<ReportProcessor<T>, ReportDestination<T>[]>

  constructor() {
    this.routes = new Map<ReportProcessor<T>, ReportDestination<T>[]>()
  }

  async uploadReport(artifacts: readonly Artifact[]): Promise<void> {
    const destinationPromises: Promise<void>[] = []
    // Start all ReportProcessors AND ReportDestination tasks.
    // The ReportDestination tasks will wait for their associated ReportProcessors.
    for (const [preProcessor, destinations] of this.routes.entries()) {
      const task = preProcessor.generateReport(artifacts)
      for (const destination of destinations) {
        destinationPromises.push(
          (async () => {
            const result = await task
            await destination.uploadReport(result)
          })()
        )
      }
    }

    // Once all processors and destinations are concluded.
    const destinationResults = await Promise.allSettled(destinationPromises)
    const destinationErrors = destinationResults.filter(
      (result): result is PromiseRejectedResult => result.status === 'rejected'
    )

    if (destinationErrors.length > 0) {
      throw new AggregateError(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        destinationErrors.map((result: PromiseRejectedResult) => result.reason)
      )
    }
  }

  /**
   * Registers a route from a {@link ReportProcessor} to a {@link ReportDestination} that operate on the same type T.
   * @param preProcessor - Processor of type T to send to the {@link destination}
   * @param destination - Destination to upload the output of {@link preProcessor} to.
   */
  registerRoute(
    preProcessor: ReportProcessor<T>,
    destination: ReportDestination<T>
  ): void {
    if (this.routes.has(preProcessor)) {
      this.routes.get(preProcessor)?.push(destination)
    } else {
      this.routes.set(preProcessor, [destination])
    }
  }
}
