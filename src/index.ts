import * as core from '@actions/core'
import * as github from '@actions/github'
import { GitHub } from '@actions/github/lib/utils'
type Octokit = InstanceType<typeof GitHub>
import { components } from '@octokit/openapi-types/types'
import { Router } from './destinations/router'
import { ActionInput, parseInputs } from './utils/input-helper'
import {
  humanReadableDate,
  humanReadableSize,
  shieldsIoBadge
} from './utils/format-helpers'
import HandlebarsReportGenerator from './preprocessor/handlebar-generator'
import handlebars from 'handlebars'
import { createGitHubWebStrategy } from './destinations/web-comment'
import { GitHubConsoleDestination } from './destinations/console'
import path from 'path'
import { TablePrinterProcessor } from './preprocessor/table-printer'

export type Comment = components['schemas']['issue-comment']
export type Artifact = components['schemas']['artifact']

export { Router } from './destinations/router'

/**
 * NCC static analysis has issues when the Handlebars template default is defined
 * in the input-helper file. We define the template path here so the packing into dist/index.js
 * can relocate the file correctly.
 */
export const HandlebarsTemplatePath = path.join(
  __dirname,
  'templates',
  'report.hbs'
)
const run = async (): Promise<void> => {
  try {
    const actionInputs: ActionInput = parseInputs()
    const octokit = github.getOctokit(actionInputs.githubToken)
    // Create our handlebars instance and register our helper funcs.
    const handlebarsInstance = handlebars.create()
    handlebarsInstance.registerHelper('pretty-date', humanReadableDate)
    handlebarsInstance.registerHelper('pretty-size', humanReadableSize)
    handlebarsInstance.registerHelper('badge', shieldsIoBadge)
    const handlebarProcessor = new HandlebarsReportGenerator(
      actionInputs.handlebarsTemplate,
      handlebarsInstance,
      github.context
    )

    // Create github comment strategy based on comment-mode input.
    const githubCommentDestination = createGitHubWebStrategy(
      octokit,
      actionInputs.issueId,
      actionInputs.commentMode,
      actionInputs.hiddenKey,
      actionInputs.owner,
      actionInputs.repo,
      actionInputs.separator
    )

    // Register routes.
    // Handlebars Markdown --> GitHub PR Comments
    // Table Printer --> GitHub Workflow Log
    const router: Router<string> = new Router<string>()
    router.registerRoute(handlebarProcessor, githubCommentDestination)
    router.registerRoute(
      new TablePrinterProcessor(),
      new GitHubConsoleDestination()
    )

    const artifacts: readonly Artifact[] = await getArtifacts(
      octokit,
      actionInputs.workflowRunId,
      actionInputs.owner,
      actionInputs.repo
    )
    await router.uploadReport(artifacts)
  } catch (maybeError: unknown) {
    if (maybeError instanceof Error) {
      if (maybeError instanceof AggregateError) {
        for (const err of maybeError.errors) {
          core.error(err as Error)
        }
      }
      core.error(maybeError.message)
      core.setFailed(maybeError)
    } else {
      console.error(maybeError)
      core.setFailed('Unknown failure. See logs for details.')
    }
  }
}

async function getArtifacts(
  octokit: Octokit,
  workflowRunId: number,
  owner: string,
  repo: string
): Promise<readonly Artifact[]> {
  const artifacts: Artifact[] = []

  for await (const page of octokit.paginate.iterator(
    octokit.rest.actions.listWorkflowRunArtifacts,
    { owner, repo, run_id: workflowRunId }
  )) {
    for (const artifact of page.data) {
      artifacts.push(artifact)
    }
  }
  return artifacts
}

/**
 * @public
 * A ReportDestination is a location where reports of type {@link ReportType} can be uploaded to.
 * ReportDestinations are generic because we want to define what types of data a ReportDestination is able to understand and upload.
 * Reports of {@link ReportType} are intended to be generated by an implementation of {@link ReportProcessor}.
 * @param ReportType - Type(s) of data that the ReportDestination is capable of uploading.
 * @example
 * This example shows how we could implement a FileDestination that is responsible for writing reports of string or byte array type to a file.
 * ```
 * import * as fs from 'node:fs/promises'
 * type StringOrByteArray = string | Uint8Array;
 * class FileDestination implements ReportDestination<StringOrByteArray> {
 *  private fileName: string;
 *  constructor(fileName: string) {
 *      this.fileName = fileName;
 *  }
 *  async upload(report: StringOrByteArray): Promise<void> {
 *      // fs.writeFile(file, data)
 *      // data is type string | Buffer | TypedArray | DataView
 *      await fs.writeFile(this.fileName, report);
 *  }
 * }
 * ```
 */
export interface ReportDestination<ReportType> {
  /**
   * Uploads a report of type {@link ReportType} to the destination.
   * @param report - Report of type {@link ReportType} to upload to the destination.
   */
  uploadReport(report: ReportType): Promise<void>
}

/**
 * @public
 * A ReportProcessor is responsible for consuming a list of artifacts and returning those artifacts as a {@link ReportType}.
 * The intended use is to convert artifacts into intermediate formats of {@link ReportType}.
 * @param ReportType - The type of the generated report.
 * @see {@link ReportProcessor.generateReport}
 */
export interface ReportProcessor<ReportType> {
  /**
   * Processes a list of Artifacts into a report of type {@link ReportType}.
   * @param artifacts - Array of artifacts to generate the report from.
   * @returns A Promise of type {@link ReportType}.
   */
  generateReport(artifacts: readonly Artifact[]): Promise<ReportType>
}

// eslint-disable-next-line @typescript-eslint/no-floating-promises
run()
